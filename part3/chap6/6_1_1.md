# 6.1.1 测试驱动开发

如果只是写一些日常用的小玩具，或者做一些不需要复用或者持续运行的数据分析项目，往往我们只需要让它可以运行并且符合预期就可以了；如果是商业项目中，我们需要追求代码的可维护、可复用、可拓展，如何才能规范开发和测试流程呢？在一个大型商业项目中，往往我们需要维护很多种不同的代码，比如服务器端使用Python、Go、Java、PHP、Ruby、Node.js等语言中的一种或者几种，客户端需要使用Web、Andorid、iOS等框架中的一种或者几种，如何制定一套不受语言特性影响的开发和测试规范呢？这个时候我们就需要**测试驱动开发**（Test-Driven Development，简称TDD）来指导开发和测试流程。

## 为何逐步引入测试驱动开发？

在搭建公司系统的早期，我并没有意识到测试驱动开发的必要性，所以是按照正常的流程去写的。以我选择的服务端框架Django+REST Framework为例，按照这套框架，我设计一个系统中的应用单元时，只需要把应用从下到上分层为模型层（models）、序列化层（serializers）、视图层（views）、模板层（templates）、API层（urls），然后从下到上一层一层实现即可。一开始我确实写的很顺利，首先定义一系列和SQL数据库映射的数据模型，比如User模型；然后定义一些把数据模型转化成Python数据类型的序列化类，比如LoginSerializer、RegisterSerializer；然后定义一些视图层函数用来解析HTTP请求报文、操作序列化后的数据、生成HTTP响应报文并返回；然后定义渲染数据生成网页的Django模板；最后定义对外访问的URL地址，做成API接口。





## 如何实践测试驱动开发？

测试驱动开发的大概可以以这样的步骤来组织：

1. 搭建系统框架，应用（app）、包（pacakge）、模块（module）、类（class）、函数（function）、数据（data）依次搭建。
2. 为应用、包、模块规定他们的主要任务，为关键的类和函数设计输入输出和功能，初步实现接口名称、输入值、输出值，搭建好一个可以调用来组织逻辑的框架。
3. 为每一个对应的应用、包、模块对应设计测试流程，为每一个类和函数创建一个单元测试类，为每一种预期的情况写一个测试函数。
4. 用上一步的框架函数和类实现预期特性写测试样例，形成测试框架。
5. 开发实现软件功能，用测试样例初步覆盖测试并且调整软件结构或者测试样例，直到预期效果实现为止。
6. 添加更多必要的测试以完善对各种情况的覆盖，并且进行集成测试等更进一步的测试。

下面我们继续用户认证这个例子来实践测试驱动开发。

### 搭建系统框架

在我们的系统里，用户认证功能使用一个Django App来实现，具体来说就是一个Django项目下的Python package，我们叫它`qtuser`。一个典型的Django REST Framework框架下的模块和包需要有：

- `models.py`：模型层
- `serializers.py`：序列化层
- `views.py`：视图层
- `templates`文件夹：模板层，在我们的系统里所有的模板层集中到一起维护。
- `urls.py`：API层
- `app.py`：Django应用配置

此外，用户认证功能还需要用户认证算法模块和用户权限模块：

- `authentication.py`：用户认证
- `permissions.py`：用户权限

### 明确开发目标

下面我们来明确每一个模块的功能，以及模块里的关键实现。

模型层，需要关注的是数据库和Django数据模型之间的交互，主要工作就是设计用户表和把Django模型迁移到SQL数据库上。这一层需要一个类，我们叫它QtUser，具体实现如下：

```python
# qtuser/models.py

class QtUser(models.Model):
  id = ...
  password = ...
  mobile = ...
  email = ...
```

序列化层，我们希望用一个通用的序列化类来实现用户认证相关的流程。这个类是整个应用中的关键设计。

```python
# qtuser/serializers.py

class UserAuthSerializer(serializers.ModelSerializer):
  # 定义外部传入的字段，比如验证码等
  code = ...
  ...
  # 定义元数据
  class Meta:
    model = QtUser
    fields = ['mobile', 'password']
  
  def validate(self, value):
    """
    验证有输入值的字段的格式是否有效
    """
    if value is None:
      return value
    # 验证逻辑
    if condition:
      raise serializers.ValidationError("...")
    return value
  
  def validate(self, data):
    """
    用户登录、注册、更新等流程时验证数据
    """
    ...
    return data
  
  def create(self, validated_data):
    """
    用户注册
    """
    user.objects.create(validated_data)
    return user
  
  def update(self, instance, validate_data):
    """
    用户更新
    """
    instance.attr = validate_data.get('attr', instance.attr)
    ...
    return instance
```



### 设计测试框架



### 实现测试样例



### 软件开发

下面我们来根据前面的框架来更新补充。

首先是模型层，由于密码不可以明文存储，所以需要专门定义对密码的相关操作。

```python
# qtuser/models.py

class QtUser(models.Model):
  # 字段
  ...
  # 处理密码的方法
  def set_passowrd(self, raw_password):
    self.password = make_password(raw_password)
    return self.password
```



### 软件测试





## 测试驱动开发带来哪些好处？

我最直观的感受是，测试驱动开发提供了一个非常自然的思路来推进开发进程。在没有进行测试驱动开发之前，我感受到在设计结构时没有清晰明确的预期结果来约束，往往在有了一个模糊的结构以后就不知道如何下手了。测试驱动开发提供了一个很好的方案，先把模糊的结构搭建出来，然后用模糊的结构来搭建测试框架，用测试框架来明确预期的效果，再返回去一个一个单元调节。原来这个结构所希望解决的一系列通用的场景是个棘手的大问题，这一个一个单元则是一个一个小问题，大问题就成功地拆分成了一系列新的小问题，每一个小问题则容易解决地多。测试驱动开发很好地帮我解决了”思路初步形成以后下一步做什么”这个困惑，这是和GTD的思路是契合的。

第二个直观的感受是约束特性实现范围对设计结构的帮助。在没有测试框架之前，初步设计的结构所要解决的问题是不够明确的，因此“这个结构需要设计的多么通用”就成了一个很棘手的问题。测试明确地约束了需要解决的问题的范围，可以很好地帮助架构和开发明确哪些设计是需要通用、可拓展的，哪些是可以暂时忽略不计的。一个没有边界的大问题被约束成了一个只需要先解决局部的小问题，如果可以留下解决下一个小问题的伏笔自然更好。而更有趣的是，这样的伏笔往往在行动的过程中产生，而不是凭空想象出来的。

进一步的好处是，测试驱动开发分离了”结构“和”特性“这两个软件开发上的重要关注点，开发更多关注如何去设计更精巧的结构，而测试保证预期的特性可以实现。有了测试框架的约束以后，设计结构和重构也变得更加灵活自由。在上面的例子中，新的设计比起初的设计复杂很多，代码量大大减少了，结构变得十分紧凑，冗余代码越来越少。如果结构必须直观地表达特性，开发者就像手脚被捆住一样，时时刻刻地关注代码结构不能破坏特性，而不是进一步地思考哪些地方可以复用或者可以抽象。比如上面的例子，注册、登录、更新等场景被抽象成了用户认证的通用流程，我们依然可以用测试框架来检验这些功能可否实现，而开发和架构可以关注用序列化类的validate、create、update方法来抽象三个功能所需要的结构，然后去关注validate方法如何实现对三类场景下验证数据时分别需要如何实现、如何复用其中共同的部分等等。

测试驱动开发还提高了项目的可拓展性。精炼的结构设计，可以让频繁地变动特性变成可能。比如说，在一个通用的用户验证序列化类的约束下，如果加入新的登录方式，比如邮箱登录，直接在现有的结构上增加只需要很少的代码更变，再加入一些新的测试即可。这个更变可能只有一些小小的量，几乎没有质变，不需要重写一遍所有的代码甚至增加一批新的代码，实现起来就会非常快。这样，一个上线的应用可以频繁地根据用户反馈调整特性实现，再辅助以持续集成、持续部署，可以实现很快的反应速度，这对于追求稳定的前提下还要追求效率的商业项目来说是非常有意义的。前面提到的流程依然可以继续遵循：首先设计和实现结构的小调整，然后覆盖一批新的测试，然后就可以加入开发计划中。

测试驱动开发也提供了很好的团队合作的框架。架构师重点关注设计开发架构和测试架构，为开发工程师搭建好基本的包、模块、类、函数和方法、数据和属性，为测试工程师明确需要测试的特性、规范测试流程；开发工程师对着测试接口，关注在架构下实现预期的特性，用单元测试初步检测特性是否实现；测试工程师写测试样例，拿到开发工程师的结果以后进行测试并且反馈问题提出建议。整个技术团队都可以把测试作为预期结果，非常方便大家形成共识，和结果导向、行动导向的GTD工作法也是契合的。

测试驱动开发已经是现代软件工程最基础的组成部分之一。在传统的按部就班的流程无法适应开发进展时，应该立刻开始逐步转移到测试驱动开发的道路上来，这对于技术架构建设是十分有帮助的。

